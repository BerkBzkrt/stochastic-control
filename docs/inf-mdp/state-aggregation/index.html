<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Aditya Mahajan" />
  <meta name="title" content="ECSE 506: Stochastic Control and Decision Theory" />
  <title>ECSE 506: Stochastic Control and Decision Theory</title>
  
  <meta content="infinite horizon,discounted cost,Lipschitz continuity,approximation bounds,state aggregation" name="keywords" />
  

  <link rel="stylesheet" href="https://adityam.github.io/stochastic-control//css/style.css" type="text/css" /><script type="text/javascript"
    src="https://adityam.github.io/stochastic-control/js/mathjax-local.js" defer>
  </script>
  <script type="text/javascript" id="MathJax-script" defer
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
  </script>

  <script type="module" defer
    src="//instant.page/3.0.0"
    integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1">
  </script>

  <script>var clicky_site_ids = clicky_site_ids || []; clicky_site_ids.push(101261731);</script>
  <script async src="//static.getclicky.com/js"></script>

</head>
<body>
<div id="content">
<div class="title">
  <h1>ECSE 506: Stochastic Control and Decision Theory </h1>
  <h2><a href="http://www.cim.mcgill.ca/~adityam/">Aditya Mahajan</a> <br/>
      Winter 2022
  </h2>
  <h3><a href="https://adityam.github.io/stochastic-control/ ">About</a>
	&nbsp;<small><small>|</small></small>&nbsp;
    <a href="https://adityam.github.io/stochastic-control//lectures">Lectures</a></span>
	&nbsp;<small><small>|</small></small>&nbsp;
    <a href="https://adityam.github.io/stochastic-control//notes">Notes</a></span>
	&nbsp;<small><small>|</small></small>&nbsp;
    <a href="https://adityam.github.io/stochastic-control//coursework">Coursework</a>
</h3>
</div>



<div class="h1-title">Theory: State aggregation or discretization or quantization</div>

<p>So far, we have studied exact solutions to the dynamic program. When the state space is large (or possibly continuous), an exact solution is not possible due to computational limitations. So, we need to look at approximate solutions.</p>
<p>The simplest form of approximate solution is <strong>state aggregation</strong>, in which we partition the state space into equivalence classes and assign one state in each class as a representative element of that class. When the state space is continuous, the procedure is called <strong>state discretization</strong> or <strong>state quantization</strong>. We will use the state quantization terminology in these notes.</p>
<h1 data-number="1" id="system-model"><span class="header-section-number">1</span> System model</h1>
<p>Consider an MDP with abstract state space <span class="math inline">\(\ALPHABET S\)</span> and finite action space <span class="math inline">\(\ALPHABET A\)</span>. We denote this MDP by <span class="math inline">\(M = (\ALPHABET S, \ALPHABET A, c, p)\)</span>. For simplicity, we assume that <span class="math inline">\(\ALPHABET S\)</span> is continuous (and compact), and that the <span class="math inline">\(p\)</span> is the density of the transition kernel. Note that we are using the term “probability density” in the engineering sense (so, it may be a combination of a continuous function and delta functions) rather than in the precise measure theoretic sense (where it is the Radon-Nikodym derivative with respect to the Lebesque measure).</p>
<p>If exact computations were possible, we can find an optimal solution by solving the following dynamic program: <span class="math display">\[ V = \mathcal B V, \]</span> that is <span class="math display">\[ V(s) = 
\min_{a \in \ALPHABET A} \biggl\{ c(s,a) 
+ \gamma \int_{\ALPHABET S} p(s&#39;|s,a) V(s&#39;) ds&#39; \biggr\},
\quad \forall s \in \ALPHABET S.
\]</span> Let <span class="math inline">\(V^*\)</span> denote the optimal value function and <span class="math inline">\(π^*\)</span> denote the optimal policy.</p>
<p>However, since the state space is continuous, we cannot compute the value functions exactly. The simplest way to proceed is to discretize or quantize the state space <span class="math inline">\(\ALPHABET S\)</span>. In particular, let <span class="math inline">\(\{\ALPHABET S_1, \dots \ALPHABET S_n\}\)</span> denote a partition of <span class="math inline">\(\ALPHABET S\)</span> (i.e., <span class="math inline">\(\bigcup_{i=1}^n \ALPHABET S_i = \ALPHABET S\)</span> and for any <span class="math inline">\(i \neq j\)</span>, <span class="math inline">\(\ALPHABET S_i \cap \ALPHABET S_j = \emptyset\)</span>). Pick a representative point <span class="math inline">\(\hat s_i \in \ALPHABET S_i\)</span>. We can think of the “grid points” <span class="math inline">\(\hat {\ALPHABET S} = \{\hat s_1, \dots, \hat s_n\}\)</span> as quantization of the state space <span class="math inline">\(\ALPHABET S\)</span>. To simplify notation, we define quantization function <span class="math inline">\(φ \colon \ALPHABET S \to \hat {\ALPHABET  S}\)</span> which maps all points in <span class="math inline">\(\ALPHABET S_i\)</span> to the representative element <span class="math inline">\(\hat s_i\)</span>.</p>
<p>We consider a finite state MDP <span class="math inline">\(\hat M = (\hat {\ALPHABET S}, \ALPHABET A, \hat c, \hat P)\)</span>, where <span class="math inline">\(\hat c\)</span> is the restriction of <span class="math inline">\(c\)</span> onto <span class="math inline">\(\hat {\ALPHABET S}\)</span>, and <span class="math inline">\(\hat P\)</span> is given by <span class="math display">\[\hat P(\hat s_j | \hat s_i, a) =
\int_{\ALPHABET S_j} p(s&#39; | \hat s_i, a) dy = p(\ALPHABET S_j | \hat s_i, a).
\]</span></p>
<p>Suppose <span class="math inline">\(\hat W^* \colon \hat S \to \reals\)</span> be the optimal value function and <span class="math inline">\(\hat μ^* \colon \hat {\ALPHABET S} \to \ALPHABET A\)</span> be the optimal policy for the approximate model. Define <span class="math inline">\(W^* \colon \ALPHABET S \to \reals\)</span> and <span class="math inline">\(μ^* \colon \ALPHABET S \to \reals\)</span> to be piecewise constant extrapolation of <span class="math inline">\(\hat W^*\)</span> and <span class="math inline">\(\hat μ^*\)</span> from <span class="math inline">\(\hat {\ALPHABET S}\)</span> to <span class="math inline">\(\ALPHABET S\)</span>, i.e., <span class="math display">\[
W^*(s) = \hat W^*(φ(s)) 
\quad\text{and}\quad
μ^*(s) = \hat μ^*(φ(s)).
\]</span> Note that the policy <span class="math inline">\(μ^*\)</span> chooses the same action on all states in a quantization cell <span class="math inline">\(\ALPHABET S_i\)</span>.</p>
<p>We are interested in two questions:</p>
<ol type="1">
<li>What is the error if <span class="math inline">\(W^*\)</span> is used as an approximation for <span class="math inline">\(V^*\)</span>?</li>
<li>What is the error if the policy <span class="math inline">\(μ^*\)</span> is used instead of the optimal policy <span class="math inline">\(π^*\)</span>?</li>
</ol>
<p>We present two methods to bound the two approximation errors. The first method bounds the errors in terms of the Lipschitz constant of <span class="math inline">\(V^*\)</span> while the second method bounds the errors in terms of the Lipschitz constant of <span class="math inline">\(\hat W^*\)</span>.</p>
<h1 data-number="2" id="bounds-in-terms-of-lipschitz-constant-of-v"><span class="header-section-number">2</span> Bounds in terms of Lipschitz constant of <span class="math inline">\(V^*\)</span></h1>
<h2 data-number="2.1" id="preliminary-results"><span class="header-section-number">2.1</span> Preliminary results</h2>
<p>We start by some preliminary results to build the intuition behind the approximation bounds. We start with a property of the discretized transition matrix.</p>
<div class="highlight">
<dl>
<dt><span id="lemma:1"></span><span id="lemma:pmf" class="pandoc-numbering-text lemma"><strong>Lemma 1</strong></span></dt>
<dd>
<p>For any <span class="math inline">\(\hat V \colon \hat {\ALPHABET S} \to \reals\)</span>, let <span class="math inline">\(V \colon \ALPHABET S \to \reals\)</span> be its piecewise constant extrapolation from <span class="math inline">\(\hat {\ALPHABET S}\)</span> to <span class="math inline">\(\ALPHABET S\)</span> (i.e., <span class="math inline">\(V = \hat V \circ φ\)</span>). Then, for any <span class="math inline">\(\hat s \in \ALPHABET S\)</span> and <span class="math inline">\(a \in \ALPHABET A\)</span>, we have <span class="math display">\[
\int_{\ALPHABET S} p(s&#39; | s,a) V(s&#39;) ds&#39; 
=
\sum_{\hat s&#39; \in \hat {\ALPHABET S}} \hat P(\hat s&#39; | \hat s, a) 
\hat V(\hat s).
\]</span></p>
</dd>
</dl>
</div>
<details>
<summary>
<h4 class="unnumbered" id="proof">Proof</h4>
</summary>
<div>
<p>Recall that <span class="math inline">\(\{\ALPHABET S_1, \dots, \ALPHABET S_n\}\)</span> is a partition of <span class="math inline">\(\ALPHABET S\)</span> and <span class="math inline">\(\ALPHABET S_i = φ^{-1}(\hat s_i)\)</span>. Therefore, <span class="math display">\[\begin{align*}
\int_{\ALPHABET S} p(s&#39;|\hat s, a) V(s&#39;) ds&#39; 
&amp;= \sum_{\hat s&#39; \in \hat {\ALPHABET S}} 
\int_{φ^{-1}(\hat s&#39;)} p(s&#39; | \hat s; a) \hat V(φ(s&#39;)) ds&#39;
\\
&amp;= \sum_{\hat s&#39; \in \hat {\ALPHABET S}} \hat V(\hat s&#39;) 
\int_{φ^{-1}(\hat s&#39;)} p(s&#39; | \hat s; a) ds&#39;
\\
&amp;= \sum_{\hat s&#39; \in \hat {\ALPHABET S}} \hat V(\hat s&#39;) 
\hat P(\hat s&#39; | \hat s, a).
\end{align*}\]</span></p>
</div>
</details>
<p>An immediate consequence of <a href="#lemma:pmf" title="Lemma 1"><span class="pandoc-numbering-link lemma">Lemma 1</span></a> is the following:</p>
<div class="highlight">
<dl>
<dt><span id="lemma:2"></span><span id="lemma:one-step" class="pandoc-numbering-text lemma"><strong>Lemma 2</strong></span></dt>
<dd>
<p>For any <span class="math inline">\(\hat V \colon \hat {\ALPHABET S} \to \reals\)</span>, let <span class="math inline">\(V \colon \ALPHABET S \to \reals\)</span> be its piecewise constant extrapolation from <span class="math inline">\(\hat {\ALPHABET S}\)</span> to <span class="math inline">\(\ALPHABET S\)</span> (i.e., <span class="math inline">\(V = \hat V \circ φ\)</span>). Define, one-step update functions: <span class="math display">\[\begin{align}
  W(s) &amp;= \min_{a \in \ALPHABET A}\biggl\{
  c(s,a) + γ \int_{\ALPHABET S} p(s&#39; | s,a) V(s&#39;) ds&#39; \biggr\}, 
  \label{eq:one-step-a}\\ 
  \hat W(\hat s) &amp;= \min_{a \in \ALPHABET  A} \biggl\{
  \hat c(\hat s,a) + γ \sum_{\hat s \in \ALPHABET S} \hat P(\hat s&#39; | s,a) \hat
  V(\hat s&#39;) \biggr\}.
  \label{eq:one-step-b}
\end{align}\]</span> Then, <span class="math display">\[\begin{equation}\label{eq:one-step}
  W(\hat s) = \hat W(\hat s), \quad \forall \hat s \in \hat {\ALPHABET S}.
\end{equation}\]</span></p>
</dd>
</dl>
</div>
<details>
<summary>
<h4 class="unnumbered" id="proof-1">Proof</h4>
</summary>
<div>
<p>Let <span class="math inline">\(π\)</span> be the optimal policy for \eqref{eq:one-step-a} and <span class="math inline">\(\hat π\)</span> be the optimal policy for \eqref{eq:one-step-b}. Fix a state <span class="math inline">\(\hat s \in \hat {\ALPHABET S}\)</span> and let <span class="math inline">\(a = π(\hat s)\)</span> and <span class="math inline">\(\hat a = \hat π(\hat s)\)</span>. Then, <span class="math display">\[\begin{align*}
W(\hat s) &amp;= c(\hat s, a) + γ \int_{\ALPHABET S}
  \hat P(\hat s&#39; | s, a) \hat V(s&#39;) ds&#39;
\\
&amp;\stackrel{(a)}= \hat c(\hat s, a) + γ
\sum_{\hat s&#39; \in \hat {\ALPHABET S}} \hat P(\hat s&#39;|\hat s, a) \hat V(\hat
s&#39;)
\\
&amp;\ge \hat W(\hat s),
\end{align*}\]</span> where <span class="math inline">\((a)\)</span> follows from definition of <span class="math inline">\(\hat c\)</span> and <a href="#lemma:pmf" title="Lemma 1"><span class="pandoc-numbering-link lemma">Lemma 1</span></a>.</p>
<p>Similarly, we have <span class="math display">\[\begin{align*}
\hat W(\hat s) &amp;= \hat c(\hat s, \hat a) + γ
\sum_{\hat s&#39; \in \hat {\ALPHABET S}} \hat P(\hat s&#39;|\hat s, \hat a) \hat V(\hat
s&#39;)
\\
&amp;\stackrel{(b)}= c(\hat s, \hat a) + γ \int_{\ALPHABET S}
  \hat P(\hat s&#39; | s, \hat a) \hat V(s&#39;) ds&#39;
\\
&amp;\ge W(\hat s),
\end{align*}\]</span> where <span class="math inline">\((b)\)</span> follows from definition of <span class="math inline">\(\hat c\)</span> and <a href="#lemma:pmf" title="Lemma 1"><span class="pandoc-numbering-link lemma">Lemma 1</span></a>.</p>
<p>Thus, <span class="math inline">\(W(\hat s) = \hat W(\hat s)\)</span>.</p>
</div>
</details>
<p><a href="#lemma:pmf" title="Lemma 1"><span class="pandoc-numbering-link lemma">Lemma 1</span></a> shows that for any quantization point <span class="math inline">\(\hat s\)</span> and action <span class="math inline">\(a\)</span>, computing the expectation of the future cost to go function <span class="math inline">\(\hat V \colon \hat {\ALPHABET S} \to \reals\)</span> with respect to the measure <span class="math inline">\(\hat P\)</span> is the same as computing the expectation of the piecewise linear extrapolation <span class="math inline">\(V\)</span> of <span class="math inline">\(\hat V\)</span> with respect to the original measure <span class="math inline">\(p\)</span>. <a href="#lemma:one-step" title="Lemma 2"><span class="pandoc-numbering-link lemma">Lemma 2</span></a> shows that the one step Bellman update of a function <span class="math inline">\(\hat V\)</span> coincides with the one-step Bellman update of its piecewise constant extrapolation <span class="math inline">\(V\)</span> at quantization points <span class="math inline">\(\hat s \in \hat {\ALPHABET S}\)</span>.</p>
<p>Note that these equivalences are valid only at quantization points <span class="math inline">\(\hat s \in \hat {\ALPHABET S}\)</span> and not for other points in <span class="math inline">\(\ALPHABET S\)</span>.</p>
<h2 data-number="2.2" id="bounding-the-error-for-value-function-approximation"><span class="header-section-number">2.2</span> Bounding the error for value function approximation</h2>
<p>So far, we haven’t used any regularity property of the model. <a href="#lemma:pmf" title="Lemma 1"><span class="pandoc-numbering-link lemma">Lemma 1</span></a> and <a href="#lemma:one-step" title="Lemma 2"><span class="pandoc-numbering-link lemma">Lemma 2</span></a> depend only on the construction of the quantized model.</p>
<p>Now suppose <span class="math inline">\(\ALPHABET S\)</span> is a bounded metric space with metric <span class="math inline">\(d_S\)</span>. Suppose the original MDP <span class="math inline">\(M\)</span> satisfies some regularity properties such that the value function <span class="math inline">\(V^*\)</span> is Lipschitz with Lipschitz constant <span class="math inline">\(\NORM{V^*}_L\)</span>, i.e., for any <span class="math inline">\(s,s&#39; \in \ALPHABET S\)</span> <span class="math display">\[ \bigl| V^*(s) - V^*(s&#39;) \bigr| \le \NORM{V^*}_L d_S(s,s&#39;). \]</span> This means that for any <span class="math inline">\(s \in \ALPHABET S\)</span>, <span class="math display">\[\begin{equation}\label{eq:lip}
\bigl| V(s) - V(φ(s)) \bigr| \le \NORM{V^*}_L D, 
\end{equation}\]</span> where <span class="math inline">\(D = \sup_{s \in \ALPHABET S} d_S(s,φ(s))\)</span> is the largest <em>radius</em> of the quantization cells. Note that since <span class="math inline">\(\ALPHABET S\)</span> is assumed to be a bounded metric space, <span class="math inline">\(D\)</span> is finite.</p>
<p>Using this idea, we can answer our first question.</p>
<div class="highlight">
<dl>
<dt><span id="prop:1"></span><span id="prop:value" class="pandoc-numbering-text prop"><strong>Proposition 1</strong></span></dt>
<dd>
<p><span class="math display">\[\NORM{ V^* - W^*}_∞ \le \frac{D}{1-γ} \NORM{V^*}_L. \]</span></p>
</dd>
</dl>
</div>
<details>
<summary>
<h4 class="unnumbered" id="proof-2">Proof</h4>
</summary>
<div>
<p>Consider any <span class="math inline">\(s \in \ALPHABET S\)</span>. Then, <span class="math display">\[\begin{align}
  \bigl| V^*(s) - W^*(s) \bigr| 
  &amp;\le \bigl| V^*(s) - V^*(φ(s)) \bigr| + \bigl| V^*(φ(s)) - \hat W^*(φ(s)) \bigr|
  \notag \\
  &amp;\le \NORM{V^*}_L D + \bigl| V^*(φ(s)) - \hat W^*(φ(s)) \bigr|
  \label{eq:step-a-1}
\end{align}\]</span></p>
<p>For the ease of notation let <span class="math inline">\(\mathcal B\)</span> and <span class="math inline">\(\hat {\mathcal B}\)</span> denote the Bellman operators for model <span class="math inline">\(M\)</span> and <span class="math inline">\(\hat M\)</span>, respectively. Now, we know that <span class="math inline">\(\hat W^* = \hat {\mathcal B} \hat W^*\)</span> and by <a href="#lemma:one-step" title="Lemma 2"><span class="pandoc-numbering-link lemma">Lemma 2</span></a> <span class="math inline">\([\hat {\mathcal B} \hat W^*](\hat s) = [\mathcal B W^*](\hat s)\)</span>. Thus, we can write the second term of \eqref{eq:step-a-1} as follows: <span class="math display">\[\begin{align*}
  \bigl| V^*(φ(s)) - \hat W^*(φ(s)) \bigr| 
  &amp;=
  \bigl| [\mathcal B V^*](φ(s)) - [ \mathcal B W^* ](φ(s)) \bigr| 
  \\
  &amp;\le γ \NORM{V^* - W^*}_∞.
\end{align*}\]</span> Substituting back in \eqref{eq:step-a-1}, we get <span class="math display">\[\bigl| V^*(s) - W^*(s) \bigr| \le \NORM{V^*}_L D + γ \NORM{V^* - W^*}_∞.\]</span> We get the result by supermizing over <span class="math inline">\(s\)</span> and rearranging the terms.</p>
</div>
</details>
<h2 data-number="2.3" id="bounding-the-error-for-policy-approximation"><span class="header-section-number">2.3</span> Bounding the error for policy approximation</h2>
<p>Using the same idea as <a href="#prop:value" title="Proposition 1"><span class="pandoc-numbering-link prop">Proposition 1</span></a>, it is possible to show that <span class="math display">\[
\NORM{V^{μ^*} - W^*}_∞ \le \frac{D}{1-γ} \NORM{V^{μ^*}}_L.
\]</span> Combining this with <a href="#prop:value" title="Proposition 1"><span class="pandoc-numbering-link prop">Proposition 1</span></a>, we get <span class="math display">\[
\NORM{V^{μ^*} - V^*}_∞ \le \NORM{V^{μ^*} - W^*}_∞ + \NORM{V^* - W^*}_∞
\le \frac{D}{1-γ} [ \NORM{V^*}_L + \NORM{V^{μ^*}}_L ].
\]</span></p>
<p>If we assume that the model is Lipschitz, then we can get a bound on <span class="math inline">\(\NORM{V^*}_L\)</span> in terms of Lipschitz constants on the cost function and the transition dynamics. However, it is difficult to bound <span class="math inline">\(\NORM{V^μ}_L\)</span> because that bound will be interms of the Lipschitz constant of the policy <span class="math inline">\(μ^* = \hat μ^* \circ φ\)</span>. So, we provide an alternative bound on <span class="math inline">\(\NORM{V^{μ^*} - W^*}_∞\)</span> in this section.</p>
<p>We assume that the model <span class="math inline">\(M\)</span> is a <span class="math inline">\((L_c, L_p)\)</span>-Lipschitz MDP.</p>
<dl>
<dt><span id="ass:1"></span><span id="ass:lip" class="pandoc-numbering-text ass"><strong>Assumpt. 1</strong></span></dt>
<dd>
<ul>
<li>For every <span class="math inline">\(a \in \ALPHABET A\)</span>, <span class="math inline">\(c(\cdot, a)\)</span> is <span class="math inline">\(L_c\)</span>-Lipschitz.</li>
<li>For every <span class="math inline">\(a \in \ALPHABET A\)</span>, <span class="math inline">\(p(\cdot | s, a)\)</span> is <span class="math inline">\(L_p\)</span>-Lipschitz (with respect to the Kantorovich distance on probability measures).</li>
</ul>
</dd>
</dl>
<p>Under this assumption, we can show the following:</p>
<div class="highlight">
<dl>
<dt><span id="prop:2"></span><span id="prop:policy" class="pandoc-numbering-text prop"><strong>Proposition 2</strong></span></dt>
<dd>
<p>Under <a href="#ass:lip" title="Assumpt. 1"><span class="pandoc-numbering-link ass">Assumpt. 1</span></a>, we have <span class="math display">\[\NORM{V^{μ^*} - V^*}_∞ \le 
  \frac{D}{1-γ} \biggl[ L_c + γ L_p \NORM{V^*}_L + 
  \frac{1 + γ}{1-γ} \NORM{V^*}_L \biggr]. \]</span></p>
<p>Furthermore, if <span class="math inline">\(γ L_p &lt; 1\)</span>, then from properties of Lipschitz MDPs, we know that <span class="math inline">\(\NORM{V^*}_L \le L_c/(1-γ)(1- γ L_p)\)</span>. Thus, <span class="math display">\[\NORM{V^{μ^*} - V^*}_∞ \le 
  \frac{2 D L_c }{ (1-γ)^2 (1-γ L_p) }. \]</span></p>
</dd>
</dl>
</div>
<details>
<summary>
<h4 class="unnumbered" id="proof-3">Proof</h4>
</summary>
<div>
<p>Fix a state <span class="math inline">\(s \in \ALPHABET S\)</span>. Let <span class="math inline">\(\hat s = φ(s)\)</span> and <span class="math inline">\(a = \hat μ^*(\hat s) = μ^*(s)\)</span>. By construction, <span class="math inline">\(W^*(s) = \hat W^*(\hat s)\)</span>. Thus, <span class="math display">\[\begin{align*}
W^*(s) &amp;= \hat W^*(\hat s) = c(\hat s, a) + γ \sum_{\hat s&#39; \in \hat {\ALPHABET S}}
\hat P(\hat s&#39; | \hat s, a) \hat W^*(\hat s&#39;).
\\
&amp;= c(\hat s, a) + γ \int_{\ALPHABET S} p(s&#39; | \hat s, a) W^*(s&#39;) ds&#39;.
\end{align*}\]</span> Moreover, <span class="math display">\[
V^{μ^*}(s) = c(s, a) + γ \int_{\ALPHABET S} 
p(s&#39;|s,a) V^{μ^*}(s&#39;) ds&#39;.
\]</span> Thus, <span class="math display">\[\begin{align}
\bigl| V^{μ^*}(s) - W^*(s) \bigr| &amp;\stackrel{(a)}\le
\bigl| c(s,a) - c(φ(s),a) \bigr| \notag \\
&amp;\quad + γ \biggl| \int_{\ALPHABET S} p(s&#39;|s,a) V^{μ^*}(s&#39;) ds&#39; 
                -  \int_{\ALPHABET S} p(s&#39;|s,a) W^*(s&#39;) ds&#39; \biggr| \notag \\
&amp;\quad + γ \biggl| \int_{\ALPHABET S} p(s&#39;|s,a) W^{*}(s&#39;) ds&#39; 
                -  \int_{\ALPHABET S} p(s&#39;|s,a) V^*(s&#39;) ds&#39; \biggr| \notag \\
&amp;\quad + γ \biggl| \int_{\ALPHABET S} p(s&#39;|s,a) V^{*}(s&#39;) ds&#39; 
                -  \int_{\ALPHABET S} p(s&#39;|\phi(s),a) V^*(s&#39;) ds&#39; \biggr| \notag \\
&amp;\quad + γ \biggl| \int_{\ALPHABET S} p(s&#39;|\phi(s),a) V^{*}(s&#39;) ds&#39; 
                -  \int_{\ALPHABET S} p(s&#39;|\phi(s),a) W^*(s&#39;) ds&#39; \biggr| 
\label{eq:step-b-1}
\end{align}\]</span> where <span class="math inline">\((a)\)</span> follows from the triangle inequality. Now, we bound each of the terms in \eqref{eq:step-b-1}. Since <span class="math inline">\(c\)</span> is Lipschitz, we have <span class="math display">\[\begin{equation} \label{eq:step-b-2}
\bigl| c(s,a) - c(φ(s),a) \bigr| \le L_c D.
\end{equation}\]</span> Moreover, <span class="math display">\[\begin{equation} \label{eq:step-b-3}
\biggl| \int_{\ALPHABET S} p(s&#39;|s,a) V^{μ^*}(s&#39;) ds&#39; 
      -  \int_{\ALPHABET S} p(s&#39;|s,a) W^*(s&#39;) ds&#39; \biggr| 
\le \NORM{ V^{μ^*} - W^*}_∞.
\end{equation}\]</span> From <a href="#prop:value" title="Proposition 1"><span class="pandoc-numbering-link prop">Proposition 1</span></a> we have <span class="math display">\[\begin{equation} \label{eq:step-b-4}
\biggl| \int_{\ALPHABET S} p(s&#39;|s,a) W^{*}(s&#39;) ds&#39; 
      -  \int_{\ALPHABET S} p(s&#39;|s,a) V^*(s&#39;) ds&#39; \biggr| 
\le \NORM{ W^* - V^*}_∞ \le \frac{D}{1-γ} \NORM{V^*}_L
\end{equation}\]</span> From the Kantorovich-Rubinstein duality, we have <span class="math display">\[\begin{equation} \label{eq:step-b-5}
\biggl| \int_{\ALPHABET S} p(s&#39;|s,a) V^{*}(s&#39;) ds&#39; 
      -  \int_{\ALPHABET S} p(s&#39;|\phi(s),a) V^*(s&#39;) ds&#39; \biggr| 
\le \mathcal {W}(p( \cdot | s,a), p(\cdot | φ(s), a)) \NORM{V^*}_L
\le L_p D \NORM{V^*}_L.
\end{equation}\]</span> Finally, from <a href="#prop:value" title="Proposition 1"><span class="pandoc-numbering-link prop">Proposition 1</span></a>, we have <span class="math display">\[\begin{equation} \label{eq:step-b-6}
\biggl| \int_{\ALPHABET S} p(s&#39;|\phi(s),a) V^{*}(s&#39;) ds&#39; 
      -  \int_{\ALPHABET S} p(s&#39;|\phi(s),a) W^*(s&#39;) ds&#39; \biggr| 
\le \NORM{V^* - W^*}_∞ \le \frac{D}{1-γ} \NORM{V^*}_L.
\end{equation}\]</span> Substituting \eqref{eq:step-b-2}–\eqref{eq:step-b-6} in \eqref{eq:step-b-1} and rearranging, we get <span class="math display">\[\begin{equation}
  \NORM{V^{μ^*} - W^*}_∞ \le \frac{D}{1-γ} \biggl[
  L_c + γ L_p \NORM{V^*}_L + \frac{2γ}{1-γ} \NORM{V^*}_L \biggr]
\end{equation}\]</span></p>
<p>This proves the first result of the Proposition. The second result follows from simple algebra.</p>
</div>
</details>
<h1 data-number="3" id="bounds-in-terms-of-lipschitz-constant-of-hat-w"><span class="header-section-number">3</span> Bounds in terms of Lipschitz constant of <span class="math inline">\(\hat W^*\)</span></h1>
<p>TODO</p>


<p class="categories">
This entry 

 was last updated on 05 May 2022
 and posted in 

<a href="https://adityam.github.io/stochastic-control/categories/mdp">
  MDP</a>
and tagged
<a href="https://adityam.github.io/stochastic-control/tags/infinite-horizon">infinite horizon</a>,
<a href="https://adityam.github.io/stochastic-control/tags/discounted-cost">discounted cost</a>,
<a href="https://adityam.github.io/stochastic-control/tags/lipschitz-continuity">lipschitz continuity</a>,
<a href="https://adityam.github.io/stochastic-control/tags/approximation-bounds">approximation bounds</a>,
<a href="https://adityam.github.io/stochastic-control/tags/state-aggregation">state aggregation</a>.</p>



    </div>
  </body>
</html>


