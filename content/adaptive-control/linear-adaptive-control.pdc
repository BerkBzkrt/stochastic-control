---
title: Adaptive control of linear systems
weight: 01
categories:
  - RL
tags:
  - Linear systems
  - Adaptive control
  - LQR
scripts:
  - math
  - plotly
  - random
---

We start with a simple example to illustrate that it is possible to control
a linear system with unknown dymamics. Consider a scalar linear system
$$ x_{t+1} = a x_t + b u_t + w_t $$
where $x_t, u_t, w_t \in \reals$ and $\{w_t\}_{t \ge 1}$ is an i.i.d.\ process
with zero mean and variance $σ^2$. Suppse the per-step cost is $c(x_t, u_t) =
x_t^2$ and our objective is to minimize the long-term average cost
$$ 
  \lim_{T \to ∞} \frac{1}{T} \EXP\Bigl[ \sum_{t=1}^T x_t^2 \Bigr].
$$
This is perhaps the simplest instance of an [LQR] problem. It is easy to
verify that the solution of the discrete-time algebric Riccati equation is
given by $S = 1$ and therefore the optimal control action is
$$
  u_t = - \frac{a}{b} x_t
$$
and the optimal average cost is $1$.

[LQR]: ../../linear-systems/lqr

Now suppose the parameters $θ = \VEC(a,b)$ are unknown. Suppose we use
linear least squares estimates to identify $θ$. Let $z_t$ denote $\VEC(x_t, u_t)$.
Note that we can write
$$ x_{t+1} = z_t^\TRANS θ + w_t. $$ 

Combining oberrvations until time $t$, we have
$$ \MATRIX{x_2 \\ \vdots \\ x_{t}} = 
   \MATRIX{z_1^\TRANS \\ \vdots \\ z_{t-1}^\TRANS } θ + 
   \MATRIX{w_1 \\ \vdots \\ w_{t-1}} $$
which may be written in vector form as
$$ X_t = Z_t θ + W_t, $$
where 
$$ 
 X_t = \MATRIX{x_2 \\ \vdots \\ x_{t}}, \quad
 Z_t = \MATRIX{z_1^\TRANS \\ \vdots \\ z_{t-1}^\TRANS }, \quad
 W_t = \MATRIX{w_1 \\ \vdots \\ w_{t-1}}. $$
  


Thus, the linear least squares estimator of $θ$ is given by
$$ \hat θ_t = (Z_t^\TRANS Z_t)^{-1} Z_t^\TRANS X_t
    = \bigl[ \sum_{τ = 1}^{t-1} z_τ z_τ^\TRANS \bigr]^{-1}
              \sum_{τ=1}^{t-1} z_τ x_{τ+1}. $$

The linear least squares estimate can be written in recursive form as: $x_0 =
0$, $\Sigma_0 = 1$, and for $t \ge 0$:
\begin{align*}
  \hat θ_{t+1} &= \hat θ_t + 
  \frac{ \Sigma_t z_t ( x_{t+1} - z_t^\TRANS \hat θ_t) }{1 + z_t^\TRANS \Sigma_t z_t },
  \\
  \Sigma_{t+1} &= \Sigma_t - 
  \frac{ \Sigma_t z_t z_t^\TRANS \Sigma_t }{ 1 + z_t^\TRANS \Sigma_t z_t }.
\end{align*}

Note that it can also be shown that the covariance $\Sigma_t$ satisfies the
recusion
$$ 
  \Sigma_{t+1}^{-1} = \Sigma_t^{-1} + z_t z_t^\TRANS.
$$

Now, let $\hat θ_t = (\hat a_t, \hat b_t)$. The certainty equivalent control
law is given by 
$$
  u_t = - \frac{\hat a_t}{\hat b_t} x_t.
$$

It can be shown that under some conditions on the parameters of the model, the
sequence $\{ \hat a_t/ \hat b_t\}_{t \ge 1}$ converges to $a/b$, so
asymptotically we will use the right control law, even though $\hat θ_t$ does
not converge to $θ$.

Let's run a simple simulation to test this. Suppose $a = $ 
<input id="ex1a"
       type="number"    step = 0.1
       maxlength = "3"  size = "2"
       min = "-10"      max  = "10"
       onkeyup  = "ex1Plot()"
       onchange = "ex1Plot()"
       value = "" />,
$b = $
<input id="ex1b"
       type="number"    step = 0.1
       maxlength = "3"  size = "2"
       min = "-10"      max  = "10"
       onkeyup  = "ex1Plot()"
       onchange = "ex1Plot()"
       value = "" />,
and $σ = $
<input id="ex1σ"
       type="number"    step = 0.1
       maxlength = "3"  size = "2"
       min = "0"      max  = "10"
       onkeyup  = "ex1Plot()"
       onchange = "ex1Plot()"
       value = "" />. 
The resulting plot for a single sample path is shown below. You can generate
another sample path by clicking
<button onClick="ex1Plot()">Re-run</button>

<div class="flex">
  <div id="ex1:cost" style="width:800px; height:250px;"></div>
  <div id="ex1:parameters" style="width:800px; height:250px;"></div>
</div>

<script>
if (pagedata == undefined) { var pagedata = { } }

pagedata.adaptiveControl = { a : 0.8, b : 1, σ : 1, T : 1000 }

// Set initial values
document.getElementById('ex1a').value = pagedata.adaptiveControl.a;
document.getElementById('ex1b').value = pagedata.adaptiveControl.b;
document.getElementById('ex1σ').value = pagedata.adaptiveControl.σ;

function show_plot(dom, x, y, xtitle, ytitle) {
  var data = [{
      x : x,
      y : y,
      line : {
        shape : "spline",
      }, 
      mode : "lines" , 
  }];

  var layout = { 
      paper_bgcolor: "#fffff8",
      plot_bgcolor:  "#fffff8",
      xaxis : {
        title: xtitle,
        showgrid: true,
        showline: true,
        zeroline: false,
        showticklabels: true,
      },
      yaxis : {
        title: ytitle,
        showgrid: true,
        showline: true,
        zeroline: false,
        showticklabels: true,
      },
      automargin: true,
      margin: {
        l : 75,
        r : 15,
        b : 75,
        t : 15,
        pad : 15
      } ,
      hovermode: false,
  };

  var options = {
      staticPlot: true,
      displayModeBar: false,
  };

  Plotly.newPlot(dom, data, layout, options);
}

function ex1Plot() { 
  var T = pagedata.adaptiveControl.T ; 

  var stream = new Random();

  var a = document.getElementById('ex1a').valueAsNumber;
  var b = document.getElementById('ex1b').valueAsNumber;
  var σ = document.getElementById('ex1σ').valueAsNumber;

  var time = Array(T);
  var cost = Array(T);
  var avg  = Array(T);

  var hat_a = Array(T);
  var hat_b = Array(T); 

  var gain  = Array(T);

  var done = false;
  var attempts = 0;

  do {
    attempts++;

    var x = 0;
    var u = 0;
    var w = 0;

    var z = math.zeros(2);
    var θ = math.matrix([0, 1]); // Cannot start with b = 0!
    var Σ = math.ones(2,2);

    for (var t = 0; t < T; t++) {
      if(isNaN(x)) {
         break; // Something went wrong. Restart
      }

      time[t] = t;
      if(t == 0) {
        cost[t] = x*x;
      } else {
        cost[t] = cost[t-1] + x*x;
      }
      avg[t] = cost[t]/t;

      // math.js has weird syntax to index element
      hat_a = math.subset(θ, math.index(0));
      hat_b = math.subset(θ, math.index(1));

      gain[t] = hat_a/hat_b;

      u = - gain[t]*x;
      w = stream.normal(0, σ);
      z = math.matrix([x, u]);

      if(t == T - 1) {
        done = true;
      } else {
        
        x = a*x + b*u + w;

        // θ = Θ + Σ*z*(x - z'*θ)/(1 + z'*Σ*z)
        var normalize = 1 +  math.chain(z)
                                 .transpose()
                                 .multiply(Σ)
                                 .multiply(z)
                                 .squeeze()
                                 .done();

        var innovation = x - math.dot(z,θ);

        θ = math.add(θ, math.chain(Σ).multiply(z).multiply(innovation/normalize).done());
        Σ = math.subtract(Σ, math.chain(Σ).multiply(z).multiply(math.transpose(z)).multiply(Σ).done());

        // Renormalize hat_b to 1. Else we have multiplication and division by
        // large numbers
        // θ = math.divide(θ,hat_b);
        // Σ = math.divide(Σ, hat_b*hat_b);


      }
    }
  } while ( !done && attempts < 10 ) 
  console.log(attempts)

  show_plot('ex1:cost', time, avg, "Time", "Average cost");
  show_plot('ex1:parameters', time, gain, "Time", "Controller gain");
}

ex1Plot()


</script>


